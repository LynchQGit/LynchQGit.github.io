# gRPC

## gRPC简介 todo

## 实现
Go 使用 gRPC 的最简 demo

### 创建工程
首先创建一个新的工程目录
```shell
mkdir -p $GOPATH/src/Go-CRUD
cd $GOPATH/src/Go-CRUD

go mod init Go-CRUD
```

然后新建一个 app 目录，用于存放服务端和客户端的代码
```shell
mkdir myweb
cd myweb
```

服务目录可以根据实际情况进行调整，这里我们使用 myweb 作为服务目录名。目录结构:
```shell
tree
.
├── Makefile
├── README.md
├── go.mod
├── go.sum
└── myweb
    └── cmd
        └── server
            └── main.go
```

/Go-CRUD/myweb/cmd/server/main.go
```go
package main

import (
	"fmt"
)

func main()  {
	fmt.Println("Hello, World!")
}
```

### 创建 proto 文件
然后在 myweb 目录下创建一个 internal 目录，用于存放服务端服务的代码
我们的 proto 文件存放在 myweb/internal/pb 目录下，目录结构如下:
```shell
tree   
.
├── Makefile
├── README.md
├── go.mod
├── go.sum
└── myweb
    ├── cmd
    │   └── server
    │       └── main.go
    └── internal
        ├── pb
        │   └── myweb.proto
        ├── server
        │   └── server.go
        └── service
            └── service.go
```

/Go-CRUD/myweb/internal/pb/myweb.proto
```protobuf
syntax = "proto3";

package pb;

option go_package = "myweb/internal/pb";

service Greeter {
	rpc SayHello (HelloRequest) returns (HelloReply) {}
}

message HelloRequest {
	string name = 1;
}

message HelloReply {
	string message = 1;
}
```
我们定义了一个 Greeter 服务，包含一个 SayHello 方法，方法接收一个 HelloRequest 参数，返回一个 HelloReply 结果。
> HelloRequest 中 string name = 1; 定义了一个 name 字段，类型为 string，序号为 1。
> HelloReply 中 string message = 1; 定义了一个 message 字段，类型为 string，序号为 1。

序号是用于标识字段的唯一标识符，序号必须是正整数，从 1 开始，不能重复。

> option go_package = "myweb/internal/pb"; 指定了生成的 go 文件的包名。

### 使用 protoc 生成 Go 代码
然后我们需要生成 Go 代码，我们可以使用 protoc 工具来生成 Go 代码，首先安装 protoc 工具
```shell
# 下载 protoc
go install github.com/golang/protobuf/protoc-gen-go
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc
```

然后使用 protoc 工具生成 Go 代码
```shell
protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative myweb/internal/pb/myweb.proto
```

生成的代码目录结构如下:
```shell
tree
.
├── Makefile
├── README.md
├── go.mod
├── go.sum
└── myweb
    ├── cmd
    │   └── server
    │       └── main.go
    └── internal
        └── pb
            ├── myweb.pb.go
            ├── myweb.proto
            └── myweb_grpc.pb.go
```

/Go-CRUD/myweb/internal/pb/myweb.pb.go 这个文件是由 protoc 工具生成的 Go 代码，包含了我们定义的 HelloRequest 和 HelloReply 结构体。
```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.33.0
// 	protoc        v4.24.3
// source: myweb/internal/pb/myweb.proto

package pb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type HelloRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *HelloRequest) Reset() {
	*x = HelloRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_myweb_internal_pb_myweb_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *HelloRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HelloRequest) ProtoMessage() {}

func (x *HelloRequest) ProtoReflect() protoreflect.Message {
	mi := &file_myweb_internal_pb_myweb_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HelloRequest.ProtoReflect.Descriptor instead.
func (*HelloRequest) Descriptor() ([]byte, []int) {
	return file_myweb_internal_pb_myweb_proto_rawDescGZIP(), []int{0}
}

func (x *HelloRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type HelloReply struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *HelloReply) Reset() {
	*x = HelloReply{}
	if protoimpl.UnsafeEnabled {
		mi := &file_myweb_internal_pb_myweb_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *HelloReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HelloReply) ProtoMessage() {}

func (x *HelloReply) ProtoReflect() protoreflect.Message {
	mi := &file_myweb_internal_pb_myweb_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HelloReply.ProtoReflect.Descriptor instead.
func (*HelloReply) Descriptor() ([]byte, []int) {
	return file_myweb_internal_pb_myweb_proto_rawDescGZIP(), []int{1}
}

func (x *HelloReply) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

var File_myweb_internal_pb_myweb_proto protoreflect.FileDescriptor

var file_myweb_internal_pb_myweb_proto_rawDesc = []byte{
	0x0a, 0x1d, 0x6d, 0x79, 0x77, 0x65, 0x62, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c,
	0x2f, 0x70, 0x62, 0x2f, 0x6d, 0x79, 0x77, 0x65, 0x62, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x05, 0x6d, 0x79, 0x77, 0x65, 0x62, 0x22, 0x22, 0x0a, 0x0c, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x26, 0x0a, 0x0a, 0x48, 0x65,
	0x6c, 0x6c, 0x6f, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73,
	0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61,
	0x67, 0x65, 0x32, 0x3f, 0x0a, 0x07, 0x47, 0x72, 0x65, 0x65, 0x74, 0x65, 0x72, 0x12, 0x34, 0x0a,
	0x08, 0x53, 0x61, 0x79, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x12, 0x13, 0x2e, 0x6d, 0x79, 0x77, 0x65,
	0x62, 0x2e, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x11,
	0x2e, 0x6d, 0x79, 0x77, 0x65, 0x62, 0x2e, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x52, 0x65, 0x70, 0x6c,
	0x79, 0x22, 0x00, 0x42, 0x13, 0x5a, 0x11, 0x6d, 0x79, 0x77, 0x65, 0x62, 0x2f, 0x69, 0x6e, 0x74,
	0x65, 0x72, 0x6e, 0x61, 0x6c, 0x2f, 0x70, 0x62, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_myweb_internal_pb_myweb_proto_rawDescOnce sync.Once
	file_myweb_internal_pb_myweb_proto_rawDescData = file_myweb_internal_pb_myweb_proto_rawDesc
)

func file_myweb_internal_pb_myweb_proto_rawDescGZIP() []byte {
	file_myweb_internal_pb_myweb_proto_rawDescOnce.Do(func() {
		file_myweb_internal_pb_myweb_proto_rawDescData = protoimpl.X.CompressGZIP(file_myweb_internal_pb_myweb_proto_rawDescData)
	})
	return file_myweb_internal_pb_myweb_proto_rawDescData
}

var file_myweb_internal_pb_myweb_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_myweb_internal_pb_myweb_proto_goTypes = []interface{}{
	(*HelloRequest)(nil), // 0: myweb.HelloRequest
	(*HelloReply)(nil),   // 1: myweb.HelloReply
}
var file_myweb_internal_pb_myweb_proto_depIdxs = []int32{
	0, // 0: myweb.Greeter.SayHello:input_type -> myweb.HelloRequest
	1, // 1: myweb.Greeter.SayHello:output_type -> myweb.HelloReply
	1, // [1:2] is the sub-list for method output_type
	0, // [0:1] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_myweb_internal_pb_myweb_proto_init() }
func file_myweb_internal_pb_myweb_proto_init() {
	if File_myweb_internal_pb_myweb_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_myweb_internal_pb_myweb_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HelloRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_myweb_internal_pb_myweb_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HelloReply); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_myweb_internal_pb_myweb_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_myweb_internal_pb_myweb_proto_goTypes,
		DependencyIndexes: file_myweb_internal_pb_myweb_proto_depIdxs,
		MessageInfos:      file_myweb_internal_pb_myweb_proto_msgTypes,
	}.Build()
	File_myweb_internal_pb_myweb_proto = out.File
	file_myweb_internal_pb_myweb_proto_rawDesc = nil
	file_myweb_internal_pb_myweb_proto_goTypes = nil
	file_myweb_internal_pb_myweb_proto_depIdxs = nil
}
```

/Go-CRUD/myweb/internal/pb/myweb_grpc.pb.go 这个文件是由 protoc 工具生成的 Go 代码，包含了我们定义的 Greeter 服务。
```go
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.24.3
// source: myweb/internal/pb/myweb.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Greeter_SayHello_FullMethodName = "/myweb.Greeter/SayHello"
)

// GreeterClient is the client API for Greeter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GreeterClient interface {
	SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error)
}

type greeterClient struct {
	cc grpc.ClientConnInterface
}

func NewGreeterClient(cc grpc.ClientConnInterface) GreeterClient {
	return &greeterClient{cc}
}

func (c *greeterClient) SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error) {
	out := new(HelloReply)
	err := c.cc.Invoke(ctx, Greeter_SayHello_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GreeterServer is the server API for Greeter service.
// All implementations must embed UnimplementedGreeterServer
// for forward compatibility
type GreeterServer interface {
	SayHello(context.Context, *HelloRequest) (*HelloReply, error)
	mustEmbedUnimplementedGreeterServer()
}

// UnimplementedGreeterServer must be embedded to have forward compatible implementations.
type UnimplementedGreeterServer struct {
}

func (UnimplementedGreeterServer) SayHello(context.Context, *HelloRequest) (*HelloReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SayHello not implemented")
}
func (UnimplementedGreeterServer) mustEmbedUnimplementedGreeterServer() {}

// UnsafeGreeterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GreeterServer will
// result in compilation errors.
type UnsafeGreeterServer interface {
	mustEmbedUnimplementedGreeterServer()
}

func RegisterGreeterServer(s grpc.ServiceRegistrar, srv GreeterServer) {
	s.RegisterService(&Greeter_ServiceDesc, srv)
}

func _Greeter_SayHello_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HelloRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GreeterServer).SayHello(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Greeter_SayHello_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GreeterServer).SayHello(ctx, req.(*HelloRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Greeter_ServiceDesc is the grpc.ServiceDesc for Greeter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Greeter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "myweb.Greeter",
	HandlerType: (*GreeterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SayHello",
			Handler:    _Greeter_SayHello_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "myweb/internal/pb/myweb.proto",
}
```

### 实现 gRPC 服务端
然后我们需要实现服务端的服务，我们在 myweb/internal/service 目录下创建一个 service.go 文件
/Go-CRUD/myweb/internal/service/service.go
```go
package service

import (
	"github.com/LynchQGit/Go-CRUD/myweb/internal/pb"
	"context"
)

type GreeterService struct {
	pb.UnimplementedGreeterServer
}

func (s *GreeterService) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {
	return &pb.HelloReply{Message: "Hello " + in.Name}, nil
}
```

然后我们需要修改服务端的 main.go 文件，将服务注册到 gRPC 服务中
/Go-CRUD/myweb/cmd/server/main.go
```go
package main

import (
	"github.com/LynchQGit/Go-CRUD/myweb/internal/pb"
	"google.golang.org/grpc"
	"log"
	"net"
)

func main()  {
	s := grpc.NewServer()
	pb.RegisterGreeterServer(s, &service.GreeterService{})
	err = s.Serve(listen)
	if err != nil {
		log.Fatalf("failed to serve: %v", err)
	}
}
```

运行服务端
```shell
cd $GOPATH/src/Go-CRUD/myweb
go run main.go
```

### 测试 gRPC 服务
#### grpcurl
可以使用 grpcurl 工具测试服务端
```shell
# 安装 grpcurl
go install github.com/fullstorydev/grpcurl/cmd/grpcurl@latest

# 测试服务端
grpcurl -plaintext -d '{"name": "world"}' localhost:50051 myweb.Greeter/SayHello
# 输出
{
  "message": "Hello world"
}
```

#### Go 代码客户端测试
也可以用 Go 代码测试服务端，我们在 myweb/internal/pb_client/ 目录下创建一个 myweb.go 文件作为客户端
```go
package main

import (
	"context"
	"log"
	"google.golang.org/grpc"
	pb "github.com/LynchQGit/Go-CRUD/myweb/internal/pb" // 确保导入路径与你的项目匹配
)

func main() {
	conn, err := grpc.Dial("localhost:50051", grpc.WithInsecure())
	if err != nil {
		log.Fatalf("did not connect: %v", err)
	}
	defer conn.Close()
	c := pb.NewGreeterClient(conn)

	// 调用服务
	r, err := c.SayHello(context.Background(), &pb.HelloRequest{Name: "world"})
	if err != nil {
		log.Fatalf("could not greet: %v", err)
	}
	log.Printf("Greeting: %s", r.GetMessage())
}
```

运行客户端
```shell
go run myweb/internal/pb_client/myweb.go
2024/03/07 18:15:58 Greeting: Hello world
```

一个简单的 gRPC 服务就实现了。
